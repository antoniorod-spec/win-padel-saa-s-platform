// ============================================================
// WhinPadel - Prisma Schema
// ============================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================
// ENUMS
// ============================================================

enum UserRole {
  PLAYER
  CLUB
  ADMIN
}

enum Sex {
  M
  F
}

enum ClubStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TournamentCategory {
  A
  B
  C
}

enum TournamentFormat {
  ELIMINATION
  ROUND_ROBIN
  LEAGUE
  EXPRESS
}

enum TournamentStatus {
  DRAFT
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Modality {
  VARONIL
  FEMENIL
  MIXTO
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  REJECTED
  REFUNDED
}

enum MatchWinner {
  TEAM_A
  TEAM_B
  NONE
}

enum CategoryChangeType {
  ASCENSION
  DESCENT
}

enum CategoryChangeStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================================
// AUTH MODELS (NextAuth.js / Auth.js)
// ============================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?
  name          String?
  image         String?
  role          UserRole  @default(PLAYER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Auth.js relations
  accounts Account[]
  sessions Session[]

  // App relations
  player Player?
  club   Club?

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================================
// PLAYER
// ============================================================

model Player {
  id        String   @id @default(cuid())
  userId    String   @unique
  firstName String
  lastName  String
  city      String
  country   String   @default("MX")
  sex       Sex
  age       Int?
  phone     String?
  bio       String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Registrations where this player is player1
  registrationsAsPlayer1 TournamentRegistration[] @relation("Player1Registrations")
  // Registrations where this player is player2
  registrationsAsPlayer2 TournamentRegistration[] @relation("Player2Registrations")

  rankings        Ranking[]
  categoryChanges CategoryChange[]

  @@map("players")
}

// ============================================================
// CLUB
// ============================================================

model Club {
  id            String     @id @default(cuid())
  userId        String     @unique
  name          String
  city          String
  country       String     @default("MX")
  address       String
  rfc           String?
  phone         String?
  courts        Int        @default(0) // Total de canchas (sum of indoor + outdoor)
  indoorCourts  Int        @default(0)
  outdoorCourts Int        @default(0)
  status        ClubStatus @default(PENDING)
  rating        Float      @default(0)
  logoUrl       String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournaments Tournament[]

  @@map("clubs")
}

// ============================================================
// TOURNAMENT
// ============================================================

model Tournament {
  id               String           @id @default(cuid())
  clubId           String
  name             String
  description      String?
  startDate        DateTime
  endDate          DateTime
  category         TournamentCategory
  format           TournamentFormat
  prize            String?
  inscriptionPrice Decimal          @default(0) @db.Decimal(10, 2)
  maxTeams         Int              @default(64)
  rules            Json?
  status           TournamentStatus @default(DRAFT)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  club       Club                  @relation(fields: [clubId], references: [id], onDelete: Cascade)
  modalities TournamentModality[]

  @@map("tournaments")
}

// ============================================================
// TOURNAMENT MODALITY (e.g., Varonil 4ta within a tournament)
// ============================================================

model TournamentModality {
  id           String   @id @default(cuid())
  tournamentId String
  modality     Modality
  category     String   // e.g. "1ra", "2da", "3ra", "4ta", "5ta", "6ta", "A", "B", "C", "D"

  tournament    Tournament               @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  registrations TournamentRegistration[]
  matches       Match[]

  @@unique([tournamentId, modality, category])
  @@map("tournament_modalities")
}

// ============================================================
// TOURNAMENT REGISTRATION (a pair of players in a modality)
// ============================================================

model TournamentRegistration {
  id                    String        @id @default(cuid())
  tournamentModalityId  String
  player1Id             String
  player2Id             String
  seed                  Int?
  paymentStatus         PaymentStatus @default(PENDING)
  paymentAmount         Decimal       @default(0) @db.Decimal(10, 2)
  paymentReference      String?
  registeredAt          DateTime      @default(now())

  tournamentModality TournamentModality @relation(fields: [tournamentModalityId], references: [id], onDelete: Cascade)
  player1            Player             @relation("Player1Registrations", fields: [player1Id], references: [id])
  player2            Player             @relation("Player2Registrations", fields: [player2Id], references: [id])

  matchesAsTeamA Match[] @relation("TeamAMatches")
  matchesAsTeamB Match[] @relation("TeamBMatches")

  @@unique([tournamentModalityId, player1Id, player2Id])
  @@map("tournament_registrations")
}

// ============================================================
// MATCH
// ============================================================

model Match {
  id                     String      @id @default(cuid())
  tournamentModalityId   String
  roundName              String      // e.g. "Cuartos de Final", "Semifinales", "Final"
  roundOrder             Int         // 1 = first round, 2 = quarters, etc.
  matchOrder             Int         // order within the round
  teamARegistrationId    String?
  teamBRegistrationId    String?
  winner                 MatchWinner @default(NONE)
  scores                 Json?       // e.g. [{ setA: 6, setB: 3 }, { setA: 6, setB: 4 }]
  playedAt               DateTime?
  court                  String?
  scheduledAt            DateTime?
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt

  tournamentModality TournamentModality  @relation(fields: [tournamentModalityId], references: [id], onDelete: Cascade)
  teamARegistration  TournamentRegistration? @relation("TeamAMatches", fields: [teamARegistrationId], references: [id])
  teamBRegistration  TournamentRegistration? @relation("TeamBMatches", fields: [teamBRegistrationId], references: [id])

  @@map("matches")
}

// ============================================================
// RANKING (per player, per modality, per category)
// ============================================================

model Ranking {
  id       String   @id @default(cuid())
  playerId String
  modality Modality
  category String   // e.g. "1ra", "2da", "3ra", "4ta", "5ta", "6ta", "A", "B", "C", "D"
  points   Int      @default(0)
  played   Int      @default(0)
  wins     Int      @default(0)
  losses   Int      @default(0)

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([playerId, modality, category])
  @@map("rankings")
}

// ============================================================
// CATEGORY CHANGE (ascension/descent review)
// ============================================================

model CategoryChange {
  id           String               @id @default(cuid())
  playerId     String
  modality     Modality
  fromCategory String
  toCategory   String
  type         CategoryChangeType
  status       CategoryChangeStatus @default(PENDING)
  reason       String?
  autoApproved Boolean              @default(false)
  reviewedBy   String?
  reviewedAt   DateTime?
  createdAt    DateTime             @default(now())

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@map("category_changes")
}
